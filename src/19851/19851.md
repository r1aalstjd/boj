# [버거운 버거](https://www.acmicpc.net/problem/19851)
$\definecolor{diamond}{rgb}{0,0.7059,0.9882}$ $\definecolor{ruby}{rgb}{1.0,0,0.3843}$
> #### <img src="../images/diamond5.svg" alt="diamond5" width="20" height="20"/> $\color{diamond}\texttt{Diamond V}$

## 풀이
괄호 문자열을 오랜만에 봐서 그런지 상당히 ***버거***웠던 문제였다.

문제에서 구해야 하는 것은 괄호 문자열이 주어졌을 때 이를 올바른 괄호 문자열로 만들 수 있는 괄호의 최소 개수이다.

괄호 문자열에서 여는 괄호 `(`가 $1$, 닫는 괄호 `)`가 $-1$의 값을 갖는다고 하자.

이때, 구간의 누적 합을 구했을 때 값이 $K(K > 0)$ 이면 `(`의 수가 `)`의 수보다 $K$개 더 많음을 의미하므로, `)`를 $K$개 추가해야 올바른 괄호 문자열을 만들 수 있다.

그런데, 만약 문자열의 중간에 `(`보다 `)`의 수가 더 많아지는 지점이 존재한다면, 이때는 `(`를 그 수만큼 추가해야 올바른 괄호 문자열이 될 수 있다.
* `)()(`와 같은 예시를 생각해 보면, 구간의 누적 합이 0이지만 첫 번째 문자가 `)`이므로 `(`를 추가해야 올바른 괄호 문자열을 만들 수 있다.

문자열의 중간에서 `(`보다 `)`의 수가 더 많아지는 지점의 위치와 그 값은 문자열의 맨 앞에서부터 누적 합을 구했을 때 그 최솟값이 등장하는 위치, 즉 Prefix Minimum의 위치에 해당한다.

이때, 구간의 누적 합은 `)`를 몇 개 추가해야 하는지, 구간의 Prefix Minimum은 `(`를 몇 개 추가해야 하는지를 나타낸다.

따라서 (누적 합 + Prefix Minimum)에 해당하는 개수만큼의 괄호를 추가하면 문자열에는 `()`의 쌍이 $\min($누적 합, Prefix Minimum $)$개만큼 발생하고, 이러한 쌍을 모두 제외하더라도 올바른 괄호 문자열을 만들 수 있다.

즉, 올바른 괄호 문자열을 만들기 위해 추가해야 하는 괄호의 최소 개수는 |누적 합 - $2\space\times$ Prefix Minimum|임을 알 수 있다.

문제에서 요구하는 값을 구하기 위해 필요한 정보는 Prefix Minimum과 구간합으로, 이는 Segment Tree를 통해 구할 수 있다.

이때 구간의 문자열에 포함된 괄호를 반전하는 쿼리가 주어진다면, 이는 앞서 정의한 괄호의 값이 뒤바뀌는 것을 의미하므로, 이는 Segment Tree의 노드가 가진 구간합에 -1을 곱함으로써 해결할 수 있다.

단, 구간의 Prefix Minimum은 노드의 값을 반전할 때 Prefix Maximum이 되므로, 노드의 값에 Prefix Maximum을 추가로 저장해 두어야 반전 쿼리를 처리할 수 있게 된다.

이제, 지금까지의 내용을 종합해 Segment Tree와 Lazy Propagation을 구현하고, 쿼리의 답을 구한 후 구간의 길이를 더해 출력하면 된다.