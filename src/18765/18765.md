# [정\*수\-를\+\[만들자!\]](https://www.acmicpc.net/problem/18765) $\definecolor{platinum}{rgb}{0.1529,0.8863,0.6431}$ $\definecolor{diamond}{rgb}{0,0.7059,0.9882}$ $\definecolor{ruby}{rgb}{1.0,0,0.3843}$

> #### <img src="../images/platinum2.svg" alt="platinum2" width="20" height="20"/> $\color{diamond}\texttt{Platinum II}$

## 풀이
> Javascript는 정말로 극한의 예외 처리를 갖춘 언어임을 깨닫게 해 준 문제였다.

우선 문제의 조건으로 `Number` 자료형인 1을 나타내는 방법을 생각해보면 `+!![]`로, 5글자가 넘어간다.

따라서 단순 덧셈으로는 문제를 해결하기 어렵다는 것을 알 수 있다.

그럼, 999와 같은 수를 나타내려면 어떻게 해야 할까?

정답은 문자열의 덧셈을 이용하는 것이다.

Javascript에서 `+` 연산의 규칙을 생각해 보면 `Number`와 `String`의 덧셈 결과는 `String`이므로, 이를 이용하면 각 자리에 해당하는 숫자를 만들어 문자열로 합치는 방법을 생각할 수 있다.

- `1 + 0` → 1이다.
- `1 + "0"` → `"10"`이다.

---

그런데, 위 방법을 적용하기 위해서는 우선 각 자리에 해당하는 숫자를 `Number` 자료형으로 나타내야 하는데, 이는 1을 나타내는 명령어 `+!![]` 를 여러 개 연결하는 방법 외에는 불가능해 보인다.

위 방법을 이용해 999를 나타내려면 `+!![]` 를 9번 반복한 문자열을 3번 반복해야 하고, 여기에 문자열 덧셈을 이용하기 위한 명령어도 필요하므로, 75글자 이내로 999를 나타낼 수는 없다.

이를 해결하기 위해서는 Javascript에 관한 다음 사실을 알아야 한다.

- Javascript에서 `-` 연산은 연산자 앞뒤의 자료형을 모두 `Number`로 변환해 처리한다.
- 예시 코드
    
    ```jsx
    console.log([+!![]]+[+![]]-[], typeof([+!![]]+[+![]]-[]))
    console.log([+!![]]+[+![]]-!![], typeof([+!![]]+[+![]]-!![]))
    ```
    
    - 실행 결과
        
        ```jsx
        10 'number'
        9 'number'
        ```
    
    위 코드의 첫 번째 줄의 식은 `[1]+[0]-[]`이 되고, Javascript의 `+` 연산자 규칙에 따라 이 식은  `"1"+"0"-[]` 이 되어 `"10"-[]` 가 된다.
    
    이때 Javascript의 `-` 연산자 규칙에 의해, `[]` → 0이므로 식의 값은 10이 된다.
    
    두 번째 줄의 식도 마찬가지로 `[1]+[0]-true`가 되고,  Javascript의 `+` 연산자 규칙에 따라 이 식은 `"1"+"0"-true` → `"10"-true` 이다.
    
    Javascript의 `-` 연산자 규칙에 의해, `true` → 1이므로 식의 값은 9가 된다.
    

따라서, 9를 나타내기 위해 `+!![]` 를 9번 반복하는 대신, 위 코드처럼 10에서 1을 빼는 방법을 이용하면 명령어 수를 더욱 줄일 수 있다.

- `+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]` → 45 B
- `+!![]+[+![]]-!![]` → 17 B
- 위 두 식이 의미하는 바는 `Number` 자료형의 9로 같다.

지금까지의 정보를 종합하면, 다음과 같은 알고리즘으로 이 문제를 해결할 수 있다.

1. 0 이상 1000 이하의 정수 `i`에 대해, `i`의 각 자리 숫자 `d`에 대해 다음을 수행한다.
    1. `d`가 6 이하라면, `+!![]` 를 `d`번 반복한 문자열을 만든다.
    2. `d`가 7 이상이라면, `+!![]+[+![]]` 에 `-!![]` 를 `10-d`번 반복한 문자열을 더한다.
    3. 만든 문자열의 앞에 `[`, 뒤에 `]`를 추가한다.
    4. 만들어진 문자열을 `i`의 자릿수가 큰 순서로 저장한다.
2. 저장한 문자열을 순서대로 `+` 로 연결한 문자열을 만든다.
3. 문자열의 맨 끝에 `-[]`를 추가한다.

-----

그러나, 666과 같은 숫자는 위 알고리즘을 통해서도 75글자 안에 나타내기 어렵다.

따라서, Javascript에 관한 다음 사실을 이용해야 한다.

- Javascript에서 `*` 연산은 연산자 앞뒤의 자료형을 모두 `Number`로 변환해 처리한다.

이 사실을 이용하면 위의 알고리즘을 다음과 같이 변형할 수 있다.

- 어떤 수를 위의 알고리즘으로 75글자 이내의 문자열로 나타낼 수 있다면, 만들어진 문자열을 저장한다.
- 어떤 수를 위의 알고리즘으로 75글자 이내로 나타낼 수 없다면, 그 수를 두 수의 곱으로 인수분해한 후, 두 수를 곱한 것을 나타내는 문자열 중 **길이가 가장 짧은 것**을 저장한다.
    - 길이가 가장 짧은 것을 저장하지 않으면 아래의 해결책을 적용해도 나타낼 수 없는 수가 발생한다.

-----

그러나, 위의 `*` 연산자 해결책을 적용해도 75글자 이하로 나타낼 수 없는 수들이 있을 수 있다.

이러한 수들은 다음과 같은 일종의 편법(?)을 사용하여 해결한다.

- 위 알고리즘으로 75글자 이내로 나타낼 수 없는 수를 $k$라 하자.
- `i` $\in \mathbb{Z}$, `i` $\in [k-6, k-1] \cup[k+1, k+5]$ 을 만족하는 모든 `i`에 대해 다음을 수행한다.
    - $k-$`i` 에 해당하는 문자열과 `i`에 해당하는 문자열을 연결한다.
    - 가능한 문자열 중 길이가 가장 짧은 것을 저장한다.

실제 코드를 작성할 때는 문자열의 길이를 최대한 줄이기 위해 약간의 최적화를 더했다.

&nbsp;

[정답 코드](./Solution.cpp)